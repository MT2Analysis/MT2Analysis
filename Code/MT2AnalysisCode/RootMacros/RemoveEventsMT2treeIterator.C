#include "TEventList.h"
#include "TLorentzVector.h"
#include "TMath.h"
#include "TString.h"
#include "TObject.h"
#include "TFile.h"
#include "TDirectory.h"
#include "TH2.h"
#include "TH3.h"
#include "TF1.h"
#include "TCanvas.h"
#include "TPad.h"
#include "TLine.h"
#include "TTree.h"
#include "TCut.h"
#include "TStyle.h"
#include "TROOT.h"
#include "TH3F.h"
#include "TH2F.h"
#include "TH1F.h"
#include "TH3D.h"
#include "TH2D.h"
#include "TH1D.h"
#include "TAxis.h"
#include "TSystem.h"
#include "TMap.h"
#include "TLegend.h"
#include "TLatex.h"
#include <sstream>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <math.h>
#include <vector>
#include <stdlib.h>
#include <stdio.h>
#include <map>
#include <string>
#include <cmath>
#include <limits.h>
#include <utility>
#include <algorithm>
#include "/shome/haweber/MT2Analysis_8TeV/Code/MT2AnalysisCode/MT2Code/include/MT2tree.hh"//use your own path of MT2tree.cc

//use via root -l -b -q RemoveMT2treeIterator.C++

using namespace std;

//does the same as RemoveEventsMT2tree.C
//but uses a iterator instead of a for loop
//iterator is said to be faster
void RemoveEventsMT2treeIterator() {
// Example of Root macro to copy a subset of a Tree to a new Tree
// Only selected entries are copied to the new Tree.
// The input file has been generated by the program in $ROOTSYS/test/Event
// with   Event 1000 1 99 1
//Author: Rene Brun
   
//modified: Hannsjoerg Weber, 28/08/2013

   //make cleaning v2
   vector<pair<int,pair<int,int> > > rls; rls.clear();
//   ifstream filterdat("TOBTECFilterList.dat");
   ifstream filterdat("/shome/haweber/AODFiles_MT2SR/txtfiles/controlregion/filterRA2b/JetHT_Run2012B-13Jul2012-v1_AOD_2.txt");
   char buffer[200];
   while( filterdat.getline(buffer, 200, '\n') ){
	int rrun(-1), lls(-1), eevent(-1), d1(-1);
//	sscanf(buffer, "*\t%d\t*\t%d\t*\t%d\t*\t%d", &d1, &rrun, &lls, &eevent);
	sscanf(buffer, "%d:%d:%d",&rrun, &lls, &eevent);
	cout << rrun<<":"<<lls<<":"<<eevent << endl;
	pair<int,int> t1(lls,eevent);
	pair<int,pair<int,int> > t2(rrun,t1);
	rls.push_back(t2);
   }

   TString oldfilename = "bla.root";
   TString newfilename = "bla_cleaned3.root";

	std::ostringstream cutStream;
	std::ostringstream cutStreamBase;
	cutStream << " " 
		<< "NTausIDLoose3Hits==0"                   << "&&"
		<< "NMuons==0"                              << "&&"
		<< "NEles==0"                               << "&&"
		<< "misc.Jet0Pass ==1"                      << "&&"
		<< "misc.Jet1Pass ==1"                      << "&&"
		<< "misc.Vectorsumpt < 70";
		cutStream  << "&& misc.MinMetJetDPhi4Pt40 >0.3";
//	if(fMET) cutStream << "&&misc.MET>200&&misc.HT<=750";
//	if(fMET) cutStream << "&&misc.MET>200&&misc.HT<=750&&misc.HT>=450&&misc.MT2>200";
//	if(fHT ) cutStream << "&&misc.HT>750&&misc.MET>30";
		cutStream << "&&((misc.MET>200&&misc.HT<=750&&misc.HT>=450&&misc.MT2>200)||(misc.HT>750&&misc.MET>30&&misc.MT2>=100))";
//	         cutStream << "&&misc.MT2>=100";//lowest border in MT2
	
	cutStreamBase << " " 
      << "misc.PassJet40ID ==1"                      << "&&"
      << "(misc.HBHENoiseFlag == 0 || misc.ProcessID==10)"  << "&&" // for rare SM samples
      << "misc.CSCTightHaloIDFlag == 0"             << "&&"
      << "misc.trackingFailureFlag==0"              << "&&"
      << "misc.eeBadScFlag==0"                      << "&&"
      << "misc.EcalDeadCellTriggerPrimitiveFlag==0" << "&&"
      << "misc.TrackingManyStripClusFlag==0"             << "&&"
      << "misc.TrackingTooManyStripClusFlag==0"          << "&&"
      << "misc.TrackingLogErrorTooManyClustersFlag==0"   << "&&"
      << "misc.CrazyHCAL==0";

	TString cuts = cutStream.str().c_str();
	TString basecuts = cutStreamBase.str().c_str();
//	TString myCuts = cuts + "&&" + basecuts;
	TString myCuts = "";

   //Get old file, old tree and set top branch address
   TFile *oldfile = new TFile(oldfilename.Data());
   TTree *oldtree = (TTree*)oldfile->Get("MassTree");

   MT2tree* fMT2tree = new MT2tree();
   oldtree->SetBranchAddress("MT2tree", &fMT2tree);
   Long64_t nentries =  oldtree->GetEntries();
   Long64_t nbytes = 0, nb = 0;
   int nev =0;

   //Create a new file + a clone of old tree in new file
   TFile *newfile = new TFile(newfilename.Data(),"RECREATE");
   TTree *newtree = oldtree->CloneTree(0);

   oldtree->Draw(">>selList", myCuts);
   TEventList *myEvtList = (TEventList*)gDirectory->Get("selList");
   oldtree->SetEventList(myEvtList);
   int counter=0;
   cout << "Filtering done, size=" <<myEvtList->GetN()  << endl;
//   if(myEvtList->GetSize()==0) continue;
   while(myEvtList->GetEntry(counter++) !=-1){
	int jentry = myEvtList->GetEntry(counter-1);
	nb =  oldtree->GetEntry(jentry);   nbytes += nb;
	oldtree->SetBranchAddress("MT2tree", &fMT2tree);
	if(counter%100000==0) cout << "Process event " << counter << endl;	

	//make cleaning
	bool keep = true;
	pair <int,int> t1(fMT2tree->misc.LumiSection,fMT2tree->misc.Event);
	pair <int,pair<int,int> > t2(fMT2tree->misc.Run,t1);
  	vector<pair <int,pair<int,int> > >::iterator it;
	it = find(rls.begin(),rls.end(),t2);
	if(*it==rls[rls.size()]){ if( (t2.second).second==((*it).second).second ) keep = false;}
	else keep = false;
	if(keep) newtree->Fill();
	else{
		cout << "Erase " << (*it).first <<":"<<((*it).second).first << ":" <<((*it).second).second << endl;
	}
   }
   newtree->Print();
   newtree->AutoSave();
   delete oldfile;
   delete newfile;
}



